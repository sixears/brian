{-# LANGUAGE UnicodeSyntax #-}
module Brian.EntryFilter
  ( EntryFilter
    -- , entryMatches
  , gFilt
  , matchFilt
  ) where

import Base1T hiding ( toList )

-- base --------------------------------

import Control.Monad.Fail ( MonadFail(fail) )
import Data.Char          ( isAlpha )
import Data.Foldable      ( and, any, or )
import Data.List          ( repeat, zip )
import GHC.Exts           ( toList )
import Text.Read          ( read )

-- lens --------------------------------

import Control.Lens.Getter ( view )

-- options-applicative -----------------

import Options.Applicative ( argument, eitherReader, help, metavar )

-- optparse-plus -----------------------

import OptParsePlus ( OptReader(readM) )

-- parsers -----------------------------

import Text.Parser.Char        ( CharParsing, char, digit )
import Text.Parser.Combinators ( sepBy )

-- parser-plus -------------------------

import ParserPlus ( boundedDoubledChars, parens )

-- pcre --------------------------------

import PCRE       ( PCRE, compRE, (?=~) )
import PCRE.Base  ( pcre, reSource )
import PCRE.Error ( REParseError )

-- regex -------------------------------

import Text.RE.TDFA ( matched )

-- regex-with-pcre ---------------------

import Text.RE.PCRE.Text ()

-- safe --------------------------------

import Safe ( tailSafe )

-- text --------------------------------

import Data.Text qualified as T

-- text-printer ------------------------

import Text.Printer qualified as P

-- textual-plus ------------------------

import TextualPlus ( TextualPlus(textual'), parseTextual )

-- trifecta-plus -----------------------

import TrifectaPlus ( testParse )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import Brian.EntryData qualified as EntryData

import Brian.BTag            ( unBTags )
import Brian.Description     ( Description )
import Brian.Entry           ( Entry, actresses, description, episode, tags,
                               title )
import Brian.Episode         ( EpisodeID(unEpisodeID), epID, epName )
import Brian.OptParser       ( OptParser(optParse) )
import Brian.PredicateFilter ( PredicateFilter(EF_Conj, EF_Disj, EF_Pred),
                               ShowablePredicate(predMatch), matchFilt )

--------------------------------------------------------------------------------

newtype EpIDFilter = EpIDFilter { unEpIDFilter :: [‚Ñï] }
  deriving (Eq)

instance Printable EpIDFilter where
  print = P.text ‚àò T.intercalate "." ‚àò fmap (T.pack ‚àò show) ‚àò unEpIDFilter

instance TextualPlus EpIDFilter where
  textual' = EpIDFilter ‚ä≥ (read ‚ä≥ some digit) `sepBy` char '.'

instance OptReader EpIDFilter where
  readM = eitherReader $ parseTextual

matchEpID ‚à∑ EpIDFilter ‚Üí EpisodeID ‚Üí ùîπ
matchEpID (EpIDFilter fs) (unEpisodeID ‚Üí ds) =
   and [ maybe ùï± (‚â° f) d  | (f,d) ‚Üê zip fs ((ùïµ ‚ä≥ ds) ‚äï repeat ùïπ) ]

------------------------------------------------------------

gFilt ‚à∑ Entry ‚Üí ùîπ
gFilt e =
  let words ‚à∑ ùïã ‚Üí [ùïã] = T.split (Ô¨ß . isAlpha)
      paired_words ‚à∑ ùïã ‚Üí [(ùïã,ùïã)] = (\ xs ‚Üí zip xs (tailSafe xs)) ‚àò words
      descn_filter ‚à∑ Description ‚Üí ùîπ =
        let f ‚à∑ (ùïã,ùïã) ‚Üí ùîπ
              = \ (a,b) ‚Üí "gag" `T.isPrefixOf` (T.toLower b)
                        ‚àß (T.toLower a) ‚àâ ["no", "not"]
        in  any f ‚àò paired_words ‚àò toText
      tag_filter   = [pcre|^gagtype_(?!hand)|]    -- negative lookahead
  in  or [ descn_filter (e ‚ä£ description)
         , any (\ t ‚Üí matched $ t ?=~ tag_filter) $ toText ‚©∫ unBTags $ e ‚ä£ tags
         ]

------------------------------------------------------------

{-| Filter on Œ±, with ability to construct arbitrary conjunctions & disjunctions
    of many filters.

    The base predicate comes with a ùïã, which is used both for the `Show`
    instance and for equality.  Use with care, make sure that t the ùïã does
    indeed indicate equality.
-}

data ShowableEntryFilter = ShowableEntryFilter ùïã (Entry -> ùîπ)

instance Show ShowableEntryFilter where
  show (ShowableEntryFilter t _) = T.unpack t

instance Eq ShowableEntryFilter where
  (ShowableEntryFilter t _) == (ShowableEntryFilter t' _) = t ‚â° t'

instance ShowablePredicate ShowableEntryFilter Entry where
  predMatch (ShowableEntryFilter _ p) = p

------------------------------------------------------------

type EntryFilter = PredicateFilter ShowableEntryFilter

----------------------------------------

instance OptParser EntryFilter where
  optParse = argument readM
                      (metavar "PREDICATE" ‚äï help "entry filter")

{-
instance OptParser EntryFilter where
  optParse = EntryFilter ‚ä≥ many (option readM (—é [ long "title"
                                                 , short 't'
                                                 , help "title match PCRE"
                                                 ]))
                         ‚äµ many (strOption (—é [ long "title-filter"
                                                 , short 'T'
                                                 , help "title LIKE filter"
                                                 ]))
                         ‚äµ many (option readM (—é [ long "actress"
                                                 , short 'a'
                                                 , help "actress match PCRE"
                                                 ]))
                         ‚äµ many (option readM (—é [ long "description"
                                                 , short 'd'
                                                 , help "description match PCRE"
                                                 ]))
                         ‚äµ many (option readM (—é [ long "epname"
                                                 , long "episode-name"
                                                 , short 'e'
                                                 , help "episode name PCRE"
                                                 ]))
                         ‚äµ many (option readM (—é [ long "epid"
                                                 , long "episode-id"
                                                 , short 'p'
                                                 , help "episode ID"
                                                 ]))
-}

------------------------------------------------------------

{- | Take a parsec for an Œ±, and function of the form `Œ± ‚Üí Either Printable Œ≤`,
     and use these to build a `ParsecT`.
 -}
eitherParsec ‚à∑ (MonadFail Œº, CharParsing Œº, Printable Œµ) ‚áí
               Œº Œ± ‚Üí (Œ± ‚Üí ùîº Œµ Œ≤) ‚Üí Œº Œ≤
eitherParsec f g = f ‚â´ (\ t ‚Üí case g t of
                                 ùï∑ e ‚Üí fail $ toString e
                                 ùïΩ r ‚Üí return r)

----------------------------------------

parseRE ‚à∑ (MonadFail Œº, CharParsing Œº) ‚áí Œº PCRE
parseRE =
  eitherParsec (boundedDoubledChars '{' '}') (compRE @REParseError ‚àò T.pack)

----------------------------------------

parseEPID ‚à∑ (MonadFail Œº, CharParsing Œº) ‚áí Œº EpIDFilter
parseEPID = parens textual'

----------------------------------------

sef_title_pcre ‚à∑ PCRE ‚Üí ShowableEntryFilter
sef_title_pcre re   =
  ShowableEntryFilter ([fmt|title PCRE: %s|] (reSource re))
                      (\ e ‚Üí matched $ toText(e ‚ä£ title) ?=~ re)

----------------------------------------

sef_actress_pcre ‚à∑ PCRE ‚Üí ShowableEntryFilter
sef_actress_pcre re   =
  ShowableEntryFilter ([fmt|actress PCRE: %s|] (reSource re))
                      (\ e ‚Üí or ((matched ‚àò (?=~re) ‚àò toText) ‚ä≥
                                  toList (e ‚ä£ actresses)))

----------------------------------------

sef_epid_match ‚à∑ EpIDFilter ‚Üí ShowableEntryFilter
sef_epid_match epidf =
  ShowableEntryFilter ([fmt|epID: %T|] epidf)
                      (\ e ‚Üí maybe ùï± (matchEpID epidf)(view epID ‚ä≥ e ‚ä£ episode))

----------------------------------------

sef_epname_pcre ‚à∑ PCRE ‚Üí ShowableEntryFilter
sef_epname_pcre re   =
  ShowableEntryFilter ([fmt|epname PCRE: %s|] (reSource re))
                      (\ e ‚Üí maybe ùï± (\ n ‚Üí matched $ toText n ?=~ re)
                                     (e ‚ä£ episode ‚â´ view epName))

----------------------------------------

instance TextualPlus ShowableEntryFilter where
  textual' = char 'p' ‚ã´ (sef_epid_match ‚ä≥ parseEPID)
             -- The TextualPlus instance of PCRE allows for double-quoting.
             -- I guess that was a mistake; but anyway, we cannot easily use it
             -- here directly without adding complication to the parsing (for
             -- users)
           ‚à§ char 't' ‚ã´ (sef_title_pcre ‚ä≥ parseRE)
           ‚à§ char 'a' ‚ã´ (sef_actress_pcre ‚ä≥ parseRE)
           ‚à§ char 'e' ‚ã´ (sef_epname_pcre ‚ä≥ parseRE)

--------------------------------------------------------------------------------

{-| unit tests -}
parseTests ‚à∑ TestTree
parseTests =
  testGroup "parseTest" $
    [ testParse "t{homeLand}"   (EF_Pred $ sef_title_pcre [pcre|homeLand|])
    , testParse "a{ Ha\\tcher}" (EF_Pred $ sef_actress_pcre [pcre| Ha\tcher|])
    , testParse "p(1.02.3)"     (EF_Pred $ sef_epid_match $ EpIDFilter [1,2,3])
    , testParse "e{bongi}"      (EF_Pred $ sef_epname_pcre $ [pcre|bongi|])
    , testParse "‚ãÄ[t{homeLand},p(04.05)]"
      (EF_Conj $ (EF_Pred $ sef_title_pcre [pcre|homeLand|])
              :| [EF_Pred ‚àò sef_epid_match $ EpIDFilter [4,5]])
    , testParse "&& [ p(006)  ,t{homeLand} ]"
      (EF_Conj $ (EF_Pred $ sef_epid_match (EpIDFilter [6]))
              :| [EF_Pred $ sef_title_pcre [pcre|homeLand|]])
    , testParse "‚ãÅ[t{homeLand},p(04.05)]"
      (EF_Disj $ (EF_Pred $ sef_title_pcre [pcre|homeLand|])
              :| [EF_Pred ‚àò sef_epid_match $ EpIDFilter [4,5]])
    , testParse "‚ãÄ[t{homeLand},‚ãÅ[p(04.05),  p(1.2)]]"
      (EF_Conj $ (EF_Pred $ sef_title_pcre [pcre|homeLand|])
              :| [EF_Disj $ (   EF_Pred ‚àò sef_epid_match $ EpIDFilter [4,5])
                             :| [EF_Pred ‚àò sef_epid_match $ EpIDFilter [1,2]]])
    ]

filtTests ‚à∑ TestTree
filtTests =
  let flt_guiding = EF_Pred $ sef_title_pcre [pcre|Guiding|]
      flt_spider  = EF_Pred $ sef_title_pcre [pcre|Spider|]
      flt_ep1     = EF_Pred $ sef_epid_match (EpIDFilter [1])
      flt_ep2     = EF_Pred $ sef_epid_match (EpIDFilter [2])
      flt_spOR1   = EF_Disj (flt_spider :| [flt_ep1])
      flt_spAND1  = EF_Conj (flt_spider :| [flt_ep1])

  in  testGroup "EntryFilter"
        [ testCase "Guiding:guiding +"$ matchFilt flt_guiding EntryData.e1 @=? ùïø
        , testCase "Spider:guiding  -"$ matchFilt flt_guiding EntryData.e3 @=? ùï±
        , testCase "Guiding:spider  -"$ matchFilt flt_spider  EntryData.e1 @=? ùï±
        , testCase "Spider:spider   +"$ matchFilt flt_spider  EntryData.e3 @=? ùïø
        , testCase "Guiding:1       -"$ matchFilt flt_ep1     EntryData.e1 @=? ùï±
        , testCase "Spider:1        +"$ matchFilt flt_ep1     EntryData.e3 @=? ùïø

        , testCase "Spider:‚ãÄ[spider,1] +"$
            matchFilt (EF_Conj (flt_spider :| [flt_ep1]))     EntryData.e3 @=? ùïø
        , testCase "Spider:‚ãÄ[spider,2] +"$
            matchFilt (EF_Conj (flt_spider :| [flt_ep2]))     EntryData.e3 @=? ùï±
        , testCase "Spider:‚ãÄ[guiding,1] +"$
            matchFilt (EF_Conj (flt_guiding :| [flt_ep1]))    EntryData.e3 @=? ùï±
        , testCase "Spider:‚ãÄ[guiding,2] +"$
            matchFilt (EF_Conj (flt_guiding :| [flt_ep2]))    EntryData.e3 @=? ùï±
        , testCase "Guiding:‚ãÄ[spider,1] +"$
            matchFilt (EF_Conj (flt_spider :| [flt_ep1]))     EntryData.e1 @=? ùï±
        , testCase "Guiding:‚ãÄ[spider,2] +"$
            matchFilt (EF_Conj (flt_spider :| [flt_ep2]))     EntryData.e1 @=? ùï±

        , testCase "Spider:‚ãÅ[spider,1] +"$
            matchFilt (EF_Disj (flt_spider :| [flt_ep1]))     EntryData.e3 @=? ùïø
        , testCase "Spider:‚ãÅ[spider,2] +"$
            matchFilt (EF_Disj (flt_spider :| [flt_ep2]))     EntryData.e3 @=? ùïø
        , testCase "Spider:‚ãÅ[guiding,1] +"$
            matchFilt (EF_Disj (flt_guiding :| [flt_ep1]))    EntryData.e3 @=? ùïø
        , testCase "Spider:‚ãÅ[guiding,2] +"$
            matchFilt (EF_Disj (flt_guiding :| [flt_ep2]))    EntryData.e3 @=? ùï±
        , testCase "Guiding:‚ãÅ[spider,1] +"$
            matchFilt (EF_Disj (flt_spider :| [flt_ep1]))     EntryData.e1 @=? ùï±
        , testCase "Guiding:‚ãÅ[spider,2] +"$
            matchFilt (EF_Disj (flt_spider :| [flt_ep2]))     EntryData.e1 @=? ùï±

        , testCase "Spider:‚ãÄ[guiding,‚ãÅ[spider,1]] +"$
            let filt = EF_Conj (flt_guiding :| [flt_spOR1])
            in  matchFilt filt EntryData.e3 @=? ùï±
        , testCase "Spider:‚ãÄ[‚ãÅ[spider,1],guiding] +"$
            let filt = EF_Conj (flt_spOR1 :| [flt_guiding])
            in  matchFilt filt EntryData.e3 @=? ùï±
        , testCase "Spider:‚ãÅ[‚ãÄ[spider,1],guiding] +"$
            let filt = EF_Disj (flt_spAND1 :| [flt_guiding])
            in  matchFilt filt EntryData.e3 @=? ùïø
        ]

{-| unit tests -}
tests ‚à∑ TestTree
tests =
  testGroup "EntryFilter" [ filtTests, parseTests ]

_test ‚à∑ IO ExitCode
_test = runTestTree tests

_tests ‚à∑ ùïä ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ ùïä ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
