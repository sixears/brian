{-# LANGUAGE UnicodeSyntax #-}
module Brian.SQLite
  ( Column(Column)
  , ColumnDesc(..)
  , ColumnFlag(..)
  , ColumnName(..)
  , ColumnType(..)
  , Table(..)
  , TableFlag(..)
  , TableName
  , columnID
  , createTable
  , execute
  , execute_
  , fold
  , insertTableRows
  , type RowType
    --  , insertRow
  , insertTableRows_
  , query
  , query_
  , reCreateTable
  , withinTransaction
  ) where

import Base1T
import Debug.Trace ( traceShow )

-- base --------------------------------

import Control.Exception qualified as Exception

import Data.Foldable ( Foldable )
import Data.List     ( filter )
import Data.Proxy    ( Proxy(Proxy) )
import GHC.Exts      ( IsString(fromString) )

-- logs-plus ---------------------------

import Log ( Log )

-- logging-effect ----------------------

import Control.Monad.Log ( MonadLog, Severity(Debug, Informational) )

-- mockio-log --------------------------

import MockIO.IOClass ( HasIOClass, IOClass(IOWrite) )
import MockIO.Log     ( DoMock, HasDoMock, mkIOLME )

-- safe-exceptions ---------------------

import Control.Exception.Safe ( bracketWithError )

-- sqlite-simple -----------------------

import Database.SQLite.Simple qualified as SQLite

import Database.SQLite.Simple ( Connection, FormatError, FromRow, Query(Query),
                                ResultError, SQLError, ToRow )

-- text --------------------------------

import Data.Text qualified as Text

-- text-printer ------------------------

import Text.Printer qualified as P

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import Brian.Exceptions  ( catches )
import Brian.SQLiteError ( AsSQLiteError, SQuError, toAsSQLiteError )

--------------------------------------------------------------------------------

data ColumnType = CTypeText | CTypeInteger deriving (Show)

--------------------

instance Printable ColumnType where
  print CTypeText    = P.text "TEXT"
  print CTypeInteger = P.text "INTEGER"

------------------------------------------------------------

newtype ColumnName = ColumnName { unColumnName :: ùïã }
  deriving newtype (Eq, IsString, Ord, Show)

instance Printable ColumnName where print = P.text ‚àò unColumnName

----------------------------------------

columnID ‚à∑ ColumnName ‚Üí ùïã
columnID = (":"‚äï) ‚àò unColumnName

------------------------------------------------------------

data ColumnFlag = PrimaryKey | FlagUnique | NoInsert deriving (Eq, Show)

--------------------

instance Printable ColumnFlag where
  print PrimaryKey = P.text "PRIMARY KEY"
  print FlagUnique = P.text "UNIQUE"
  print NoInsert   = P.text ""

------------------------------------------------------------

data Column = Column { cname  :: ColumnName
                     , ctype  :: ColumnType
                     , cflags :: [ColumnFlag]
                     }

--------------------

instance Printable Column where
  print (Column { cname, ctype, cflags }) =
    let flags = —é $ (" " ‚äï) ‚àò toText ‚ä≥ cflags
    in  P.text $ [fmt|%T %T %t|] cname ctype flags

------------------------------------------------------------

data TableFlag = OkayIfExists
               | ForeignKey [ColumnName]
  deriving (Eq, Show)

------------------------------------------------------------

newtype TableName = TableName { unTable :: ùïã }
  deriving newtype (IsString, Show)

instance Printable TableName where print = P.text ‚àò unTable

------------------------------------------------------------

-- data ColumnTips = NoAttrs | NoInsert deriving (Eq)

------------------------------------------------------------

data ColumnDesc = ColumnDesc ColumnName ColumnType [ColumnFlag]
  deriving (Show)

cName ‚à∑ ColumnDesc ‚Üí ùïã
cName (ColumnDesc n _ _) = unColumnName n

{- Which columns to use for insert -}
insertColumns ‚à∑ Foldable œÜ ‚áí œÜ ColumnDesc ‚Üí [ùïã]
insertColumns (toList ‚Üí cols) =
  let noInsert (ColumnDesc _ _ flags) = NoInsert ‚àà flags
  in  cName ‚ä≥ filter (Ô¨ß ‚àò noInsert) cols

{- columns description for CREATE TABLE statements -}
instance Printable ColumnDesc where
  print (ColumnDesc nm tp flgs) = P.text $
    let x = [fmt|%T %T %t|] nm tp (Text.intercalate " " $ filter (‚â¢ "") $ toText ‚ä≥ flgs)
    in traceShow ("x",x,"flgs",show flgs) $ x
------------------------------------------------------------

class Table Œ± where
  type RowType Œ±
  tName   ‚à∑ Proxy Œ± ‚Üí TableName
  columns ‚à∑ Proxy Œ± ‚Üí NonEmpty ColumnDesc
  createColumns ‚à∑ Proxy Œ± ‚Üí [ùïã]
  createColumns = toText ‚©∫ toList ‚àò columns

------------------------------------------------------------

execute ‚à∑ ‚àÄ Œµ Œæ œâ Œº .
          (MonadIO Œº, ToRow Œæ, AsSQLiteError Œµ, MonadError Œµ Œº, Printable Œµ,
           MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ) ‚áí
          Severity ‚Üí Connection ‚Üí Query ‚Üí Œæ ‚Üí DoMock ‚Üí Œº ()
execute sev conn sql r =
  let handlers = [ Exception.Handler $ return ‚àò toAsSQLiteError @SQLError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @FormatError
                 ]
      io       = ((SQLite.execute conn sql r) `catches` handlers)
  in  mkIOLME sev IOWrite ([fmtT|sqlex %w|] sql) () io

----------------------------------------

execute_ ‚à∑ ‚àÄ Œµ œâ Œº . (MonadIO Œº, AsSQLiteError Œµ, MonadError Œµ Œº, Printable Œµ,
                      MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ,HasDoMock œâ)‚áí
           Severity ‚Üí Connection ‚Üí Query ‚Üí DoMock ‚Üí Œº ()
execute_ sev conn sql =
  let handlers = [ Exception.Handler $ return ‚àò toAsSQLiteError @SQLError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @FormatError
                 ]
      io       = ((SQLite.execute_ conn sql) `catches` handlers)
  in  mkIOLME sev IOWrite ([fmtT|sqlex %w|] sql) () io

----------------------------------------

query ‚à∑ ‚àÄ Œµ Œæ œá œâ Œº .
        (MonadIO Œº, ToRow Œæ, FromRow œá,
         AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
         Default œâ, HasIOClass œâ, HasDoMock œâ, MonadLog (Log œâ) Œº) ‚áí
        Severity ‚Üí Connection ‚Üí Query ‚Üí Œæ ‚Üí [œá] ‚Üí DoMock ‚Üí Œº [œá]
query sev conn sql r mock_value =
  let handlers = [ Exception.Handler $ return ‚àò toAsSQLiteError @SQLError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @FormatError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @SQuError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @ResultError
                 ]
      io       = ((SQLite.query conn sql r) `catches` handlers)
  in  mkIOLME sev IOWrite ([fmtT|sqlqy %w|] sql) mock_value io

----------------------------------------

{- `query` that takes no parameters -}
query_ ‚à∑ ‚àÄ Œµ œá œâ Œº .
         (MonadIO Œº, FromRow œá,
          AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
          MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ) ‚áí
         Severity ‚Üí Connection ‚Üí Query ‚Üí [œá] ‚Üí DoMock ‚Üí Œº [œá]
query_ sev conn sql mock_value =
  let handlers = [ Exception.Handler $ return ‚àò toAsSQLiteError @SQLError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @FormatError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @SQuError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @ResultError
                 ]
      io       = ((SQLite.query_ conn sql) `catches` handlers)
  in  mkIOLME sev IOWrite ([fmtT|sqlqy %w|] sql) mock_value io

----------------------------------------

{- Fold doesn't perform multiple, e.g., inserts; it folds the potentially many
   rows of results back to a single result. -}
fold ‚à∑ ‚àÄ Œµ Œæ œá Œ± œâ Œº .
       (MonadIO Œº, ToRow Œæ, FromRow œá,
        AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
        MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ) ‚áí
       Severity ‚Üí Connection ‚Üí Query ‚Üí Œæ ‚Üí Œ± ‚Üí (Œ± ‚Üí œá ‚Üí IO Œ±) ‚Üí Œ± ‚Üí DoMock ‚Üí Œº Œ±
fold sev conn sql r ini acc mock_value =
  let handlers = [ Exception.Handler $ return ‚àò toAsSQLiteError @SQLError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @FormatError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @SQuError
                 , Exception.Handler $ return ‚àò toAsSQLiteError @ResultError
                 ]
      io       = ((SQLite.fold conn sql r ini acc) `catches` handlers)
  in  mkIOLME sev IOWrite ([fmtT|sqlqy %w|] sql) mock_value io

----------------------------------------

{-
data Table = Table { _tname  :: TableName
                   , _tflags :: [TableFlag]
                   , _tcols  :: [Column]
                   }

tname ‚à∑ Lens' Table TableName
tname = lens _tname (\ t n ‚Üí t { _tname = n })

tflags ‚à∑ Lens' Table [TableFlag]
tflags = lens _tflags (\ t fs ‚Üí t { _tflags = fs })

tcols ‚à∑ Lens' Table [Column]
tcols = lens _tcols (\ t cs ‚Üí t { _tcols = cs })

-}

-- CREATE TABLE Entry (id INTEGER  PRIMARY KEY, title TEXT , medium TEXT , actresses TEXT , description TEXT );

createTable ‚à∑ ‚àÄ Œµ Œ± œâ Œº . Table Œ± ‚áí
              (MonadIO Œº, AsSQLiteError Œµ, MonadError Œµ Œº, Printable Œµ,
               MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ) ‚áí
              Connection ‚Üí Proxy Œ± ‚Üí DoMock ‚Üí Œº ()
createTable conn p mck =
  let cols = Text.intercalate ", " $ createColumns p
      sql = fromString $ [fmt|CREATE TABLE %T (%t)|] (tName p) cols
  in  execute_ Informational conn sql mck

----------------------------------------

reCreateTable ‚à∑ ‚àÄ Œµ Œ± œâ Œº . Table Œ± ‚áí
                (MonadIO Œº, AsSQLiteError Œµ, MonadError Œµ Œº, Printable Œµ,
                 MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ) ‚áí
                Connection ‚Üí Proxy Œ± ‚Üí DoMock ‚Üí Œº ()
reCreateTable conn p mck = do
  let sql = fromString $ [fmt|DROP TABLE %T|] (tName p)
  execute_ Informational conn sql mck
--  createTable conn (t & tflags ‚äß filter (‚â¢ OkayIfExists)) mck
  createTable conn p mck

----------------------------------------

-- œá is the type of the returned row, e.g., (Only ID) for a single value
{-
insertRow ‚à∑ ‚àÄ Œµ Œ± Œæ œá œâ Œº . Table Œ± ‚áí
            (MonadIO Œº, ToRow Œæ, FromRow œá,
             AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
             MonadLog (Log œâ) Œº, Default œâ, HasIOClass œâ, HasDoMock œâ) ‚áí
            Severity ‚Üí Connection ‚Üí Œ± ‚Üí ùïÑ ùïã ‚Üí Œæ ‚Üí [œá] ‚Üí DoMock ‚Üí Œº [œá]
insertRow sev conn t extra r =
  let sql = fromString $ [fmt|INSERT INTO %T (%L) VALUES (%L)%T|]
                         (t ‚ä£ tname) (cname ‚ä≥ t ‚ä£ tcols)
                         (const ("?"‚à∑ùïã) ‚ä≥ t ‚ä£ tcols) (maybe "" (" " ‚äï) extra)
  in  query sev conn sql r
-}

----------------------------------------

withinTransaction ‚à∑ (MonadIO Œº, AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
                     Default œâ, HasIOClass œâ, HasDoMock œâ, MonadLog (Log œâ) Œº)‚áí
                    Connection ‚Üí DoMock ‚Üí Œº Œ± ‚Üí Œº Œ±
withinTransaction conn mck io = do
  execute_ Debug conn "BEGIN TRANSACTION" mck
  results ‚Üê io
  execute_ Debug conn "COMMIT TRANSACTION" mck
  return results

----------------------------------------

insertTableRows_ ‚à∑ ‚àÄ Œµ Œ± Œ≤ œâ Œº .
                   (MonadIO Œº, Table Œ±, ToRow (RowType Œ±), FromRow Œ≤,
                    AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
                    Default œâ, HasIOClass œâ, HasDoMock œâ, MonadLog (Log œâ) Œº) ‚áí
                   Severity ‚Üí Proxy Œ± ‚Üí Connection ‚Üí [RowType Œ±] ‚Üí ùïã ‚Üí DoMock
                 ‚Üí Œº [(RowType Œ±, [Œ≤])]
insertTableRows_ sev p conn rows extra mck = do
  let sql = traceShow ("c",columns p) $ Query $ [fmt|INSERT INTO %T (%L) VALUES (%L)%t%T|] (tName p)
                    (insertColumns ‚àò toList $ columns p) (const ("?"‚à∑ùïã) ‚ä≥ (insertColumns ‚àò toList $ columns p))
                    (if extra ‚â° "" then "" else " ") extra
  forM rows $ \ row ‚Üí (row,) ‚ä≥ query sev conn sql row —Ñ mck

----------------------------------------

insertTableRows ‚à∑ ‚àÄ Œµ Œ± Œ≤ œâ Œº .
                  (MonadIO Œº, Table Œ±, ToRow (RowType Œ±), FromRow Œ≤,
                   AsSQLiteError Œµ, Printable Œµ, MonadError Œµ Œº,
                   Default œâ, HasIOClass œâ, HasDoMock œâ, MonadLog (Log œâ) Œº) ‚áí
                  Severity ‚Üí Proxy Œ± ‚Üí Connection ‚Üí [RowType Œ±] ‚Üí ùïã ‚Üí DoMock
                ‚Üí Œº [(RowType Œ±, [Œ≤])]
insertTableRows sev p conn rows extra mck =
  withinTransaction conn mck $ insertTableRows_ sev p conn rows extra mck
{-
  execute_ Debug conn "BEGIN TRANSACTION" mck
  let sql = Query $ [fmt|INSERT INTO %T (%L) VALUES (%L)%t%T|] (tName p)
                    (insertColumns ‚àò toList $ columns p) (const ("?"‚à∑ùïã) ‚ä≥ (insertColumns ‚àò toList $ columns p))
                    (if extra ‚â° "" then "" else " ") extra
  results ‚Üê forM rows $ \ row ‚Üí (row,) ‚ä≥ query sev conn sql row —Ñ mck

  execute_ Debug conn "COMMIT TRANSACTION" mck
  return results
-}

-- that's all, folks! ----------------------------------------------------------
